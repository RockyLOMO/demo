@startuml
hide empty description
state 编排流程{
'[*] --> 后台编排流程
后台编排流程 --> 动态编排组件
note bottom of 动态编排组件
* 业务流程中角色执行的动作行为，例如：医生开方、药师发药。所有业务场景均可适配。
* 动作职责单一，高内聚低耦合。
   使得系统更加抽象灵活、可复用扩展和可测试。
* 动作定义契约，通过明确定义接口、前置条件、后置条件和不变式等契约规范，
   使得开发者更好地理解和定义组件之间的关系和职责。
end note

后台编排流程 --> 动态编排事件
note right of 动态编排事件
* 包含动作执行的前置事件、后置事件及自定义事件。
   例如：医生开方通知药师审核、药师发药通知患者拿药。
* 事件通过逻辑解耦、扩展性和灵活性等优势，
   使得系统更加可维护、可扩展和灵活，从而提高了代码的质量和可复用性。
end note

后台编排流程 --> 动态编排拦截器
note bottom of 动态编排拦截器
* 动作执行的前置和后置拦截，拦截器可以提供通用的处理逻辑集中在一起，
   例如权限验证、日志记录、异常处理等，这些处理逻辑可以在多个地方重复使用，
   且将这些关注点从业务逻辑中剥离出来，使得代码更加纯粹和专注且易于维护。
* 拦截器提供了一种灵活、可重用和统一处理的机制，使得代码结构更加清晰，功能更加模块化，
   有助于提高代码的可维护性和可扩展性。
end note

动态编排组件 --> 发布流程编排
动态编排事件 --> 发布流程编排
动态编排拦截器 --> 发布流程编排
发布流程编排:热发布编流程排规则
}

流程编排服务 -[dashed]-> 编排流程
流程编排服务:流程编排元数据存入本地缓存，轻量级高性能。
流程编排服务 --> 获取已编排发布的流程组件
获取已编排发布的流程组件:根据业务渠道或其它自定义算法获取流程组件
获取已编排发布的流程组件:校验流程执行阶段及状态合法性
获取已编排发布的流程组件:获取流程组件编排的拦截器和事件
获取已编排发布的流程组件 --> 执行拦截器和组件以及事件
执行拦截器和组件以及事件 --> 返回结果
返回结果:记录当前流程执行阶段及状态
返回结果 --> [*]
note left of 获取已编排发布的流程组件
* 通过领域驱动设计和契约式编程设计适配任何业务场景的业务组件，组件可以形成组件库，
   这些组件可以是已经存在的第三方组件，也可以是自己编写的可重用组件。
* 事件和拦截器的逻辑解耦、内聚和复用。
* 流程编排服务对组件的组合编排，将选择的组件组合在一起且正确处理组件之间的依赖关系使之形成流程。
* 定义的契约配合组件的组合能更加方便编写单元测试和集成测试，确保组件之间的协作和功能的正确性。
这种流程编排方法可以提高代码的可重用性、可维护性和可扩展性，并且能够更灵活地构建和定制系统。
最终<color:red>提高项目可维护性，降低开发成本。提高项目可变更性，适应业务变更。</color>
end note

[*] --> Http接口
[*] --> MQ消费
[*] --> 业务服务
Http接口 --> 流程编排服务
MQ消费 --> 流程编排服务
业务服务 --> 流程编排服务
@enduml
